TP : Durcir un projet Django _ BORDEAUX Marie-Charlotte

Etape 1 : Création du projet de test -> ok

Etape 2 : Page web de test -> ok
    creation de la page home + css + url afin d'afficher un template basique a l'écran
    -> ok

Etape 3 : Diagnostic de sécurité initial
    identifier les problèmes de sécurité actuels du projet.
    Apres avoir lancer la commande :
    _____ python manage.py check --deploy > baseline.txt 2>&1 _____

    Nous obtenons un fichier 'baseline.txt' pour voir les avertissements/erreurs de sécurité que Django détecte.
    Cette etape permet de durcir l'application en repérant les failles de sécurité.
    ~~> Retourne 6 WARNINGS : (security.W004), (security.W008), (security.W009),
    (security.W012), (security.W016), (security.W018)
    Exemple : 3 Warning
--->  (security.W018) You should not have DEBUG set to True in deployment.
        DEBUG=True → Django tourne en mode debug.
        Nous sommes toujours en developpement. Mais en déploiement, il faudra DEBUG=False.
--->  (security.W018) You should not have DEBUG set to True in deployment.
        SESSION_COOKIE_SECURE non activé
        Les cookies de session ne sont pas marqués “Secure”.
        Sera corrigé en mettant SESSION_COOKIE_SECURE = True (en prod).
---> (security.W009) Your SECRET_KEY has less than 50 characters, less than 5 unique characters, or it's prefixed with 'django-insecure-' indicating that it was generated automatically by Django. Please generate a long and
random value, otherwise many of Django's security-critical features will be vulnerable to attack.
        SECRET_KEY faible
        Django a généré une clé par défaut : django-insecure-xxxx.
        Il faut remplacer la secret-key par une clé plus longue et aléatoire, toujours dans le ''.env'.

Etape 4 : Configuration DEV/PROD
        Dans le settings.py :
            # SECURITY WARNING: keep the secret key used in production secret!
            SECRET_KEY = env('SECRET_KEY')

            #Varaiable pour activer le mode sécurisé
            DJANGO_SECURE = os.getenv('DJANGO_SECURE', 'False').lower() == 'true'

            #En production, DEBUG doit être FALSE
            DEBUG = not DJANGO_SECURE
            #DEBUG = env('DEBUG')

            # Domaines autorisés
            ALLOWED_HOSTS = ['127.0.0.1', 'localhost']
            #ALLOWED_HOSTS = env.list('ALLOWED_HOSTS', default=['127.0.0.1', 'localhost'])

            #Pour HTTPS local sur port 8443
            #CSRF_TRUSTED_ORIGINS = env.list('CSRF_TRUSTED_ORIGINS', default=[])
            CSRF_TRUSTED_ORIGGINS = [
                'https://127.0.0.1',
                'http://localhost',
                'http://localhost:8443',
            ]
        DEBUG doit être à FALSE en production par question de sécurité. Dans le but d'empecher
        aux utilisateurs malveillants d'accéder aux données sensibles de l'appilcation ou du site.
        Il est même recommander de mettre se paramettre dans le '.env' et de l'appelé dans le
        fichier 'settings.py'.

Etape 5 : Sécurisation des cookies
         Protéger les cookies contre le vol et les attaques.
            #Cookies et sessions
            #redirige tout le trafic vers HTTPS.
            ~~> SECURE_SSL_REDIRECT= True

            #COOKIES QUE pour HTTPS
            #Cela indique au navigateur d'envoyer ces cookies uniquement via des connexions HTTPS.
            ~~> SESSION_COOKIE_SECURE = True
            # la protection CSRF empêchera toute acceptation de données POST via HTTP
            ~~> CSRF_COOKIE_SECURE = True

            #Si ce paramètre est défini sur True,
            # le JavaScript côté client ne pourra pas accéder au cookie de session.
            ~~> SESSION_COOKIE_HTTPONLY = True
            #garder sur false pour les requêtes Ajaw si besoin
            #Si ce paramètre est défini sur True,
            # le JavaScript côté client ne pourra pas accéder au cookie CSRF.
            ~~> CSRF_COOKIE_HTTPONLY = True

            #Cet indicateur empêche l'envoi du cookie dans les requêtes intersites,
            # empêchant ainsi les attaques CSRF et rendant impossible
            # certaines méthodes de vol de cookie de session.
            #'Strict': empêche le cookie d'être envoyé par
            # le navigateur au site cible dans tous
            # les contextes de navigation intersites, même en suivant un lien régulier.
            ~~> SESSION_COOKIE_SAMESITE= 'lax'
            #Cet indicateur empêche l'envoi du cookie dans les requêtes intersites.
            ~~> CSRF_COOKIE_SAMESITE = 'LAX'

Etape 6 : HTTPS et HSTS
https://docs.djangoproject.com/en/5.2/ref/middleware/#http-strict-transport-security
        Forcer l'utilisation d'HTTPS et activer HSTS (HTTP Strict transport Security).

        HSTS est un en-tête HTTP qui informe le navigateur que toutes les futures connexions
        à un site particulier doivent toujours utiliser HTTPS. Associé à la redirection
        des requêtes HTTP vers HTTPS, cela garantit que les connexions bénéficient toujours
        de la sécurité supplémentaire de SSL, à condition qu'une connexion ait réussi.
        HSTS peut être configuré avec SECURE_HSTS_SECONDS, SECURE_HSTS_INCLUDE_SUBDOMAINS,
        et SECURE_HSTS_PRELOAD, ou sur le serveur web.

            # Redirections & HSTS (uniquement en prod derrière HTTPS)
            #Redirige tout le trafic vers HTTPS.
            SECURE_SSL_REDIRECT = True

            SECURE_HSTS_SECONDS = 31536000 if True else 0
            #Si True, Security Middlewarela directive est ajoutée includeSubDomains
            # à l' en-tête HTTP Strict Transport Security . Elle n'a aucun effet,
            # sauf si SECURE_HSTS_SECONDS elle est définie sur une valeur différente de zéro.
            SECURE_HSTS_INCLUDE_SUBDOMAINS = True
            SECURE_HSTS_PRELOAD = True

Etape 7 : Headers de sécurité
        Ajouter des header http qui protègent contre diverses attaques.

        Qu'est ce que le clickJacking :  Ce type d'attaque se produit lorsqu'un
        site malveillant incite un utilisateur à cliquer sur un élément caché d'un autre site,
        chargé dans un cadre ou une iframe caché.
        X_FRAME_OPTIONS :
        Les navigateurs modernes respectent l'en-tête HTTP X-Frame-Options ,
        qui indique si une ressource peut être chargée dans un cadre ou une iframe.
        Si la réponse contient l'en-tête avec la valeur «SAMEORIGIN »,
        le navigateur ne chargera la ressource dans un cadre que si la requête provient du même site.
        Si l'en-tête est défini sur DENY« », le navigateur bloquera
        le chargement de la ressource dans un cadre, quel que soit le site à l'origine de la requête.

        Django propose plusieurs façons d'inclure cet en-tête dans les réponses de votre site :
        1.Un middleware qui définit l'en-tête dans toutes les réponses.
        2.Un ensemble de décorateurs de vue qui peuvent être utilisés pour
        remplacer le middleware ou pour définir uniquement l'en-tête pour certaines vues.

        L' X-Frame-Options en-tête HTTP ne sera défini par le middleware ou les décorateurs
        de vue que s'il n'est pas déjà présent dans la réponse.

Etape 8 : Content Security Policy (CSP)
        Implémenter une CSP pour bloquer l'exécution de code malveillant.
    La console du naivgateur retourne ce message d'erreur :
               Refused to execute inline script because it violates
                the following Content Security Policy directive:
                "script-src 'self'". Either the 'unsafe-inline' keyword, a hash
                ('sha256-JYtB2qaxzL3oQZw2p7NvcjhlzoK4Mmd5I/0pH2xOM5E='),
                or a nonce ('nonce-...') is required to enable inline execution.
                Comprendre cette erreur
               Unchecked runtime.lastError: The message port closed
                before a response was received.
      L’alerte alert('Test XSS') ne s’exécute pas. C’est le comportement attendu
       pour un test de CSP.

Etape 9 : Validation des configurations
